---
title: "WebContainersを使わない独自アプローチで実現するブラウザ内のNode.js学習環境"
emoji: "👨‍💻"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["react", "nodejs", "serviceworker", "webpack"]
publication_name: "progate"
published: true
published_at: 2024-12-16 12:00 #公開日時の設定。
---

## はじめに

現代のフロントエンド技術の進化に伴い、ブラウザ内でサーバーサイドの処理を再現する試みが増えています。その中でも`WebContainers` や `CodeSandbox` は、Node.js環境をブラウザ上で実現する代表的なソリューションです。しかし、それらの技術を利用せずに、ブラウザネイティブな形でNode.jsの機能を再現できないか？

この疑問を出発点に、独自の手法でこの課題に挑戦しました。

Progateの社内勉強会で発表した時を起点に僕の中でどうしてもこの環境を最後まで実現したいという思いが強くなり、実際に実装に取り組んでみました。

https://youtu.be/Gk_-DSLbRSE?si=CzdDZF6XWTR8Qstq

勉強会で発表した時点の段階だと、まだまだ実装が不完全でしたが、その後も継続して実装を進め、ようやく完成に至りました。

この記事では、Progateで提供している学習プラットフォームの一部回収を目指し、
ブラウザ上でNode.jsに限りなく近い環境を構築する過程と技術的チャレンジについて詳述します。

## Node.js学習環境の現状と課題

ProgateではNode.jsの学習環境を提供しており、現在の実装はAWSのサーバー上で動作しています。ユーザーがブラウザ上でコードを記述・実行すると、そのコードはサーバーサイドで評価され、結果が返却される仕組みです。このアプローチは安定して動作していますが、以下の課題があります。

- **運用の負荷:** サーバーインフラの管理、Node.jsバージョンの更新やセキュリティ対応が必要。
- **柔軟性の欠如:** サーバー依存のため、新しい環境への展開が容易ではない。
- **コスト面の問題:** 接続数の増加への対応にコストがかかる。

## なぜWebContainersを採用しなかったのか？

すでにブラウザーでNode.jsを動かすための技術として、`WebContainers` や `Nodebox`といった技術が存在します。
WebContainersは確かに強力な技術ですが、以下の制約がプロジェクトにとって障壁となりました。

- **ブラウザ依存性:** WebContainersは現在、Chrome系ブラウザでのみ動作します。ユーザーが多様なブラウザを使用する環境では、限定的な対応は課題となります。
- **商用利用のコスト:** エンタープライズ向けのライセンスが必要であり、長期的な運用においてコスト面での障壁があります。
- **カスタマイズ性の限界:** WebContainersは高度に最適化されていますが、その分内部の仕組みに踏み込んでのカスタマイズが難しく、自社の特化したニーズに応える柔軟性が低いと判断しました。

## デモページ

![](https://storage.googleapis.com/zenn-user-upload/94b27f4f6748-20241214.png)

以下のデモページでは、ブラウザ上で`npm install` → `npm start` の流れを体験できます。

`ejs`や`express`、`sqlite`などがブラウザーだけで動作することが確認できます！

特にちゃんとexpressのプレビュー環境が画面右側に表示される箇所を見ていただきたいです！
エディターでコードを書くとちゃんとその結果がリアルタイムに反映されることが確認できます！

https://pub-6bc4a3e4095b41239156a48e59d19f54.r2.dev/index.html

## 実装のアプローチ

### requireのしくみ

Node.jsのrequireメソッドを再現するため、Webpack内部で使用されているenhanced-resolveライブラリを改造しました。
依存解決後、esbuildでコードをバンドルし、ブラウザ上で評価します。

https://github.com/webpack/enhanced-resolve

https://esbuild.github.io/

このアプローチにより、ブラウザ上でのモジュール依存解決が可能となりました。

### fsの仕組み

ファイルシステムの再現にはmemfsを採用しました。これはメモリ内で動作する仮想的なファイルシステムを提供し、Node.jsのfsモジュールを模倣します。

https://github.com/streamich/memfs

`memfs`というライブラリは、Node.jsのfsの仕組みを再現するためのライブラリです。
ブラウザーでそのまま動くのが特徴で、`fs`をかなり忠実に再現していて、実際に物理的にファイルを書き換えるのではなく、メモリ上でファイルを操作するファイルシステムを提供しています。

### Node.jsの標準モジュール

以下のようなNode.js標準モジュールをブラウザで再現しました

- `path`や`stream`: Polyfillを利用。
- `http`: Service Workerを活用し、ブラウザのネットワークレイヤーで挙動を模倣。

特に`http` モジュールは、ネットワーク要求をハンドリングする複雑なロジックが必要でした。Service Workerを用いることでリクエストの再ルーティングを実現しました。

#### 時には改造が必要

必要に応じてNode.jsでしか動かないようなモジュールを既存のライブラリやpolyfillを`patch-package`というライブラリを利用し、なんとかをブラウザで動くように改造しました。
`patch-package`を使うと、`node_modules`内のパッケージを修正するためのパッチを作成し、`package.json`に記述することができます。
そうすることで`npm install`を実行するたびに修正が上書きされることを防ぐことができます。

https://www.npmjs.com/package/patch-package

### シェルコマンドの再現

ブラウザ上に仮想シェル環境を構築し、`cd`、`ls`、`rm` といったコマンドを再現しました。これにより、Node.jsが内部で依存するOS的な操作の一部をエミュレート可能にしています。

## 課題と今後の展望

本環境の実現は一定の成果を挙げましたが、未解決の課題も残されています。

### 1. コアモジュールの再現

`net`、`crypto`、`perf_hooks`といった一部のコアモジュールは、ブラウザでの再現が難しいため、未対応です。

### 2. メモリやパフォーマンス最適化

processごとに専用のWorkerを立ち上げるなどパフォーマンスの最適化をしたいなと考えています。

また、`Node.js`のコードの実行をシミュレートするためにリアルタイムにブラウザでWebpackの内部で使われている`enhanced-resolve`を利用しています。
この技術だと、モジュールの解決が遅いため、Rustで書かれたより高速に動作する`Rspack`というライブラリも使ってみたいと考えています。

`Rspack`も`enhanced-resolve`と同じようにNode.jsのモジュールを解決するしくみがあるようです！

https://rspack.dev/guide/features/module-resolution

## さいごに

このようにProgateでは、ブラウザ上で様々な言語の学習環境を提供するという技術的にはとても面白い取り組みをしています。
興味を持たれた方はぜひProgateで一緒に働きましょう！
